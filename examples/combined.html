<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>eCSStender Example: combined rotation and rounded corners</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en-us" />
    <meta name="author" content="" />
    <meta name="MSSmartTagsPreventParsing" content="true" />
    <meta name="ROBOTS" content="ALL" />
    <meta name="Copyright" content="Copyright (c) 2008. All rights reserved." />
    <meta http-equiv="imagetoolbar" content="no" />
    <meta name="Rating" content="General" />
    <link rel="stylesheet" type="text/css" media="screen" href="css/screen.css" />
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="../src/eCSStender.js"></script>
    <script type="text/javascript">
      // <![CDATA[
      eCSStender.register(
        { 'fragment': 'transform',
          'filter': {
            'value': /rotate\(-?\d+?\)/
          },
          'test':     function()
          {
            var rotate = 'matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0)'; // rotate(45deg)
            return ( ! eCSStender.isSupported( 'property', 'transform: ' + rotate ) &&
                     ( eCSStender.isSupported( 'property', '-moz-transform: ' + rotate ) ||
                       eCSStender.isSupported( 'property', '-webkit-transform: ' + rotate ) ||
                       eCSStender.isSupported( 'property', '-khtml-transform: ' + rotate ) ||
                       eCSStender.isSupported( 'property',
                                               "filter: progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand')" ) ) );
          },
          'fingerprint': 'net.easy-designs.transform.rotate'
        },
        false,
        function( selector, properties, medium ){
          var style_block = selector + ' { ';
          
          var rotate = 'matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0)'; // rotate(45deg)
          var prefix = ( eCSStender.isSupported( 'property', '-moz-transform: ' + rotate ) ||
                         eCSStender.isSupported( 'property', '-webkit-transform: ' + rotate ) ||
                         eCSStender.isSupported( 'property', '-khtml-transform: ' + rotate ) );
          var MS = eCSStender.isSupported( 'property', "filter: progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand')" );
          
          // Microsoft uses Matrix filters
          if ( MS )
          {
            style_block += '';
            // create the transform origin function
            function addToMatrix( el, additions )
            {
              var
              params = el.style.filter.replace( /.*?Microsoft\.Matrix\((.*?)\)/, '$1' ).split(','),
              param, i,
              str = 'progid:DXImageTransform.Microsoft.Matrix(';
              if ( el.style.filter != '' )
              {
                i = params.length;
                while ( i-- )
                {
                  param = params[i].split('=');
                  if ( typeof( additions[param[0]] ) != 'undefined' &&
                       additions[params[i][0]] != false )
                  {
                    str += getParamString( param[0], additions[param[0]] );
                    additions[param[0]] = false;
                  }
                  else
                  {
                    str += getParamString( param[0], param[1] );
                  }
                }
              }
              for ( param in additions )
              {
                if ( ! eCSStender.isInheritedProperty( additions, param ) )
                {
                  str += getParamString( param, additions[param] );
                }
              }
              str = str.substring( 0, str.length-1 ) + ')';
              el.style.filter   = str;
              el.style.msfilter = str;
            }
            function getParamString( property, value )
            {
              var
              type = typeof( value ),
              str  = property + '=';
              if ( type.toLowerCase() == 'number' )
              {
                str += value;
              }
              else
              {
                str += "'" + value + "'";
              }
              return str + ',';
            }
            if ( typeof( eCSStender.methods['setOrigin'] ) == 'undefined' )
            {
              eCSStender.addMethod( 'setOrigin', function( el, x, y ){
                // set the filter
                addToMatrix( el, {
                  'Dx': x,
                  'Dy': y 
                });
              });
              // create the rotation function
              eCSStender.addMethod( 'rotate', function( el, degrees ){
                $el = $( el );
                var original_height = $el.height();
                var original_width  = $el.width();
                var radians  = degrees * ( Math.PI * 2 / 360 );
                var costheta = Math.cos( radians );
                var sintheta = Math.sin( radians );
                // set the filter
                addToMatrix( el, {
                  'M11': costheta,
                  'M12': -sintheta,
                  'M21': sintheta,
                  'M22': costheta,
                  'SizingMethod': 'auto expand'
                });
                var vertical_offset = original_height - $el.height();
                var horizontal_offset = $el.width() - original_width;
                if ( $el.css('position') == 'static' )
                {
                  $el.css({
                    'position': 'relative',
                    'top':      vertical_offset + 'px',
                    'left':     horizontal_offset + 'px'
                  });
                }
                else
                {
                  var
                  top  = $el.css('top'),
                  left = $el.css('left');
                  $el.css({
                    'top':  ( vertical_offset + parseInt( top != 'auto' ? top : 0 ) ) + 'px',
                    'left': ( horizontal_offset + parseInt( left != 'auto' ? left : 0 ) ) + 'px'
                  });
                }
              });
            }
          }
          
          // capture the value
          var degrees = parseInt( properties['transform'].replace( /rotate\((-?\d+?)\)/, '$1' ) );
          for ( var prop in properties )
          {
            // Mozilla, Webkit or Konquerer
            if ( prefix )
            {
              if ( prop == 'transform' )
              {
                style_block += '-moz-transform: rotate(' + degrees + 'deg); ' +
                               '-webkit-transform: rotate(' + degrees + 'deg); ' +
                               '-khtml-transform: rotate(' + degrees + 'deg); ';
              }
              else
              {
                style_block += '-moz-' + prop + ': ' + properties[prop] + '; ' +
                               '-webkit-' + prop + ': ' + properties[prop] + '; ' +
                               '-khtml-' + prop + ': ' + properties[prop] + '; ';
              }
            }
            // Microsoft
            else if ( MS )
            {
              switch ( prop )
              {
                case 'transform':
                  $( selector ).each(function(){
                    eCSStender.methods.rotate( this, degrees );
                  });
                  break;
                case 'transform-origin':
                  $( selector ).each(function(){
                    var $this = $( this );
                    var height = $this.height();
                    var width  = $this.width();
                    var coords = properties[prop].split(' ');
                    // by default 50% 50%
                    var x;
                    // keywords
                    if ( coords[0] == 'top' ||
                         parseInt( coords[0] ) == 0 ||
                         coords[1] == 'top' )
                    {
                      x = 0;
                    }
                    else if ( coords[0] == 'bottom' ||
                              coords[1] == 'bottom' )
                    {
                      x = width;
                    }
                    // percentage
                    else if ( coords[0].match(/\d+?%/) )
                    {
                      x = width * ( 100 / parseInt( coords[0] ) );
                    }
                    // pixels
                    else if ( coords[0].match(/\d+?px/) )
                    {
                      x = parseInt( coords[0] );
                    }
                    // default (50%)
                    else
                    {
                      x = width / 2;
                    }
                    var y;
                    // keywords
                    if ( coords[0] == 'left' ||
                         coords[1] == 'left' ||
                         parseInt( coords[1] ) == 0 )
                    {
                      y = 0;
                    }
                    else if ( coords[0] == 'right' ||
                              coords[1] == 'right' )
                    {
                      y = height;
                    }
                    // percentage
                    else if ( coords[1].match(/\d+?%/) )
                    {
                      y = height * ( 100 / parseInt( coords[1] ) );
                    }
                    // pixels
                    else if ( coords[1].match(/\d+?px/) )
                    {
                      y = parseInt( coords[1] );
                    }
                    // default (50%)
                    else
                    {
                      y = height / 2;
                    }
                    eCSStender.methods.setOrigin( this, x, y );
                  });
                  break;
              }
              
            }
          }
          style_block += '} ';
          eCSStender.embedCSS( style_block, medium );
        }
      );
      // This script makes use of the jQuery library
      eCSStender.register(
        { 'selector': ':nth-child(even), :nth-child(odd)',
          'test':     function(){
            // the markup
            var div = document.createElement('div');
            var p   = document.createElement('p');
            div.appendChild( p );
            // the test
            return ( ! eCSStender.isSupported( 'selector', 'div p:nth-child(odd)', div, p ) );
          }
        },
        '*',
        function( selector, properties, medium, specificity ){
          $( selector ).each(function(){
            eCSStender.applyWeightedStyle( this, properties, specificity );
          });
        }
      );
      eCSStender.register(
        { 'fragment': 'radius',
          'test':     function()
          {
            return ( ! eCSStender.isSupported( 'property', 'border-top-left-radius: 3px' ) &&
                     ( eCSStender.isSupported( 'property', '-moz-border-radius-topleft: 3px' ) ||
                       eCSStender.isSupported( 'property', '-webkit-border-bottom-left-radius: 3px' ) ||
                       eCSStender.isSupported( 'property', '-khtml-border-bottom-left-radius: 3px' ) ) );
          },
          'fingerprint': 'net.easy-designs.border-radius'
        },
        false,
        function( selector, properties, medium ){
          var style_block = selector + ' { ';
          
          // mozilla currently messes up the individual assignment, so we need to manage that
          var transpose = false;
          if ( eCSStender.isSupported( 'property', '-moz-border-radius-topleft: 3px' ) )
          {
            transpose = true;
          }
          
          // shorthand
          if ( typeof( properties['border-radius'] ) != 'undefined' )
          {
            // handle radii or just plain old corners
            var
            radii = properties['border-radius'].split('/'),
            corners = [];
            if ( radii.length > 1 )
            {
              var horiz = eCSStender.trim( radii[0] ).split(' ');
              var vert  = eCSStender.trim( radii[1] ).split(' ');
              // handle mirroring
              if ( horiz.length < 4 )
              {
                if ( typeof( horiz[1] ) == 'undefined' ){ horiz[1] = horiz[0]; }
                if ( typeof( horiz[2] ) == 'undefined' ){ horiz[2] = horiz[0]; }
                if ( typeof( horiz[3] ) == 'undefined' ){ horiz[3] = horiz[1]; }
              }
              if ( vert.length < 4 )
              {
                if ( typeof( vert[1] ) == 'undefined' ){ vert[1] = vert[0]; }
                if ( typeof( vert[2] ) == 'undefined' ){ vert[2] = vert[0]; }
                if ( typeof( vert[3] ) == 'undefined' ){ vert[3] = vert[1]; }
              }
              // some browsers can't handle compund radii yet
              var compound = true;
              if ( ! eCSStender.isSupported( 'property', '-webkit-border-bottom-left-radius: 3px 3px' ) &&
                   ! eCSStender.isSupported( 'property', '-moz-border-radius-bottomleft: 3px 3px' ) &&
                   ! eCSStender.isSupported( 'property', '-khtml-border-bottom-left-radius: 3px 3px' ) )
              {
                compound = false;
              }
              for ( var i=0; i<4; i++ )
              {
                corners[i] = compound ? horiz[i] + ' ' + vert[i] : horiz[i];
              }
            }
            else
            {
              corners = properties['border-radius'].split(' ');
            }
            if ( corners.length > 1 )
            {
              // webkit/konquerer is a little funky with multiple-assignment
              if ( eCSStender.isSupported( 'property', '-webkit-border-bottom-left-radius: 3px' ) ||
                   eCSStender.isSupported( 'property', '-khtml-border-bottom-left-radius: 3px' ) )
              {
                style_block += '-webkit-border-top-left-radius: ' + corners[0] + '; ' +
                               '-webkit-border-top-right-radius: ' + corners[1] + '; ' +
                               '-webkit-border-bottom-right-radius: ' + corners[2] + '; ' +
                               '-webkit-border-bottom-left-radius: ' + corners[3] + '; ' +
                               '-khtml-border-top-left-radius: ' + corners[0] + '; ' +
                               '-khtml-border-top-right-radius: ' + corners[1] + '; ' +
                               '-khtml-border-bottom-right-radius: ' + corners[2] + '; ' +
                               '-khtml-border-bottom-left-radius: ' + corners[3] + '; ';
              }
              else
              {
                style_block += '-moz-border-radius-topleft: ' + corners[0] + '; ' +
                               '-moz-border-radius-topright: ' + corners[1] + '; ' +
                               '-moz-border-radius-bottomright: ' + corners[2] + '; ' +
                               '-moz-border-radius-bottomleft: ' + corners[3] + '; ';
              }
            }
            else
            {
              style_block += '-moz-border-radius: ' + properties['border-radius'] + '; ' +
                             '-webkit-border-radius: ' + properties['border-radius'] + '; ' +
                             '-khtml-border-radius: ' + properties['border-radius'] + '; ';
            }
            properties['border-radius'] = null;
          }
          
          for ( var prop in properties )
          {
            if ( eCSStender.isInheritedProperty( properties, prop ) ) { continue; };
            if ( transpose )
            {
              style_block += prop.replace( /border-(top|bottom)-(left|right)-radius/, '-moz-border-radius-$1$2' ) +
                             ': ' + properties[prop] + '; ';
            }
            else
            {
              style_block += prop + ': ' + properties[prop] + '; ';
            }
          }
          style_block += '} ';
          eCSStender.embedCSS( style_block, medium );
        }
      );
      // ]]>
    </script>
  </head>
  <body>
    <div id="content">
      <h1>Combined Rotation and Rounded Corners</h1>
      <p>In this example, the div to the right should have rounded corners and it should be rotated -15 degrees.</p>
    </div>
    <div id="sidebar">
      <p>This example should work completely in</p>
      <ul>
        <li>Chrome</li>
        <li>Firefox 3.5+</li>
        <li>Safari 4+</li>
      </ul>
    </div>
  </body>
</html>